class VideoSplitter {
    constructor() {
        this.initializeEventListeners();
        this.setupDragAndDrop();
        this.setupScrollAnimations();
        this.setupTheme();
        this.s3Enabled = false;
        this.checkS3Status();
    }

    async checkS3Status() {
        try {
            const response = await fetch('/api/status');
            const data = await response.json();
            this.s3Enabled = data.s3_enabled;
            if (this.s3Enabled) {
                console.log('‚úÖ S3 storage enabled - large file support available');
            } else {
                console.log('‚ö†Ô∏è S3 storage not available - using local processing');
            }
        } catch (error) {
            console.log('‚ö†Ô∏è Could not check S3 status');
        }
    }

    initializeEventListeners() {
        const fileInput = document.getElementById('videoFile');
        fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        
        // New upload button
        document.getElementById('newUploadBtn').addEventListener('click', () => {
            this.resetUI();
        });

        // Mobile menu
        document.getElementById('mobileMenuBtn').addEventListener('click', () => {
            document.querySelector('.nav-links').classList.toggle('active');
        });

        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.nav') && window.innerWidth <= 768) {
                document.querySelector('.nav-links').classList.remove('active');
            }
        });
    }

    setupDragAndDrop() {
        const uploadArea = document.getElementById('uploadArea');
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleFile(files[0]);
            }
        });

        uploadArea.addEventListener('click', () => {
            document.getElementById('videoFile').click();
        });
    }

    setupScrollAnimations() {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate');
                }
            });
        }, { threshold: 0.1 });

        document.querySelectorAll('.scroll-animate').forEach(el => {
            observer.observe(el);
        });
    }

    setupTheme() {
        const themeToggle = document.getElementById('themeToggle');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedTheme = localStorage.getItem('theme') || (prefersDark ? 'dark' : 'light');
        
        document.documentElement.setAttribute('data-theme', savedTheme);
        this.updateThemeIcon(savedTheme);

        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            this.updateThemeIcon(newTheme);
        });
    }

    updateThemeIcon(theme) {
        const icon = document.querySelector('#themeToggle i');
        icon.className = theme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
    }

    handleFileSelect(e) {
        const file = e.target.files[0];
        if (file) {
            this.handleFile(file);
        }
    }

    async handleFile(file) {
        // Validate file
        if (!this.validateFile(file)) return;

        // Show file info
        this.showFileInfo(file);

        // Start upload and processing
        if (this.s3Enabled && file.size > 25 * 1024 * 1024) {
            // Use S3 for files larger than 25MB
            await this.uploadAndProcessS3(file);
        } else {
            // Use local processing for smaller files
            await this.uploadAndProcessLocal(file);
        }
    }

    validateFile(file) {
        // Check file size (1GB limit)
        if (file.size > 1024 * 1024 * 1024) {
            this.showToast('File size must be less than 1GB', 'error');
            return false;
        }

        // Check file type
        const allowedTypes = [
            'video/mp4', 'video/avi', 'video/quicktime', 
            'video/x-matroska', 'video/x-ms-wmv', 'video/x-flv', 
            'video/webm', 'video/x-m4v'
        ];
        
        if (!allowedTypes.includes(file.type)) {
            this.showToast('Please select a valid video file format', 'error');
            return false;
        }

        return true;
    }

    showFileInfo(file) {
        const fileInfo = document.getElementById('fileInfo');
        const fileSize = (file.size / (1024 * 1024)).toFixed(2);
        const method = this.s3Enabled && file.size > 25 * 1024 * 1024 ? '‚òÅÔ∏è Cloud Upload' : '‚ö° Direct Processing';
        
        fileInfo.innerHTML = `
            <h4>üìπ ${file.name}</h4>
            <p>üìä Size: ${fileSize} MB | üé¨ Type: ${file.type}</p>
            <p>üöÄ Method: ${method}</p>
        `;
        fileInfo.style.display = 'block';
    }

    async uploadAndProcessS3(file) {
        this.showProgress();
        this.updateProgress(5, 'üîÑ Preparing cloud upload...');

        try {
            // Step 1: Get presigned URL
            this.updateProgress(10, 'üîó Getting upload URL...');
            const presignedResponse = await fetch('/generate_presigned_url', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filename: file.name
                })
            });

            const presignedData = await presignedResponse.json();

            if (!presignedData.presigned_url) {
                throw new Error(presignedData.error || 'Failed to get upload URL');
            }

            // Step 2: Upload directly to S3
            this.updateProgress(20, '‚òÅÔ∏è Uploading to cloud storage...');
            
            const uploadResponse = await fetch(presignedData.presigned_url, {
                method: 'PUT',
                body: file,
                headers: {
                    'Content-Type': file.type
                }
            });

            if (!uploadResponse.ok) {
                throw new Error('Cloud upload failed');
            }

            // Step 3: Start processing
            this.updateProgress(40, 'ü§ñ Starting AI analysis...');
            
            const processResponse = await fetch('/process_video', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    object_name: presignedData.object_name,
                    session_id: presignedData.session_id
                })
            });

            const processData = await processResponse.json();

            if (processData.success) {
                this.updateProgress(100, 'üéâ Processing complete!');
                setTimeout(() => this.showResults(processData), 1000);
            } else {
                throw new Error(processData.error || 'Processing failed');
            }

        } catch (error) {
            console.error('S3 upload error:', error);
            this.showToast('Error processing video: ' + error.message, 'error');
            this.resetUI();
        }
    }

    async uploadAndProcessLocal(file) {
        const formData = new FormData();
        formData.append('video', file);

        this.showProgress();

        // Simulate progress updates
        const progressUpdates = [
            { percent: 10, text: 'üì§ Uploading video...' },
            { percent: 25, text: 'ü§ñ AI analyzing content...' },
            { percent: 45, text: '‚ö° Optimizing segmentation...' },
            { percent: 70, text: 'üé¨ Splitting video into segments...' },
            { percent: 85, text: 'üì¶ Creating ZIP package...' },
            { percent: 95, text: '‚úÖ Finalizing download...' }
        ];

        let currentProgress = 0;
        const progressInterval = setInterval(() => {
            if (currentProgress < progressUpdates.length) {
                const update = progressUpdates[currentProgress];
                this.updateProgress(update.percent, update.text);
                currentProgress++;
            }
        }, 800);

        try {
            // Send to backend for actual processing
            const response = await fetch('/upload', {
                method: 'POST',
                body: formData
            });

            clearInterval(progressInterval);

            const data = await response.json();

            if (data.success) {
                this.updateProgress(100, 'üéâ Processing complete!');
                setTimeout(() => this.showResults(data), 1000);
            } else {
                throw new Error(data.error || 'Processing failed');
            }

        } catch (error) {
            clearInterval(progressInterval);
            console.error('Error:', error);
            this.showToast('Error processing video: ' + error.message, 'error');
            this.resetUI();
        }
    }

    showProgress() {
        document.getElementById('uploadArea').style.display = 'none';
        document.getElementById('progressContainer').style.display = 'block';
        document.getElementById('resultsContainer').style.display = 'none';
    }

    updateProgress(percent, text) {
        document.getElementById('progressFill').style.width = percent + '%';
        document.getElementById('progressText').textContent = text;
        document.getElementById('progressStatus').textContent = text;
    }

    showResults(data) {
        document.getElementById('progressContainer').style.display = 'none';
        document.getElementById('resultsContainer').style.display = 'block';

        const resultDetails = document.getElementById('resultDetails');
        resultDetails.innerHTML = `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin: 2rem 0;">
                <div style="text-align: center; padding: 1rem; background: rgba(255,255,255,0.2); border-radius: 8px;">
                    <div style="font-size: 2rem; font-weight: 700;">${data.segment_count}</div>
                    <div style="opacity: 0.8;">Segments Created</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: rgba(255,255,255,0.2); border-radius: 8px;">
                    <div style="font-size: 2rem; font-weight: 700;">${data.total_duration}</div>
                    <div style="opacity: 0.8;">Total Duration</div>
                </div>
            </div>
        `;

        const downloadBtn = document.getElementById('downloadBtn');
        
        if (data.download_url) {
            // S3 download
            downloadBtn.onclick = () => {
                window.open(data.download_url, '_blank');
                this.showToast('‚úÖ Download started from cloud storage!', 'success');
            };
        } else {
            // Local download
            downloadBtn.onclick = () => this.downloadResult(data.zip_filename);
        }
    }

    async downloadResult(filename) {
        try {
            this.showToast('Starting download...', 'success');
            
            const response = await fetch(`/download/${filename}`);
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'segmented_videos.zip';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                this.showToast('Download completed successfully!', 'success');
            } else {
                throw new Error('Download failed');
            }
        } catch (error) {
            console.error('Download error:', error);
            this.showToast('Download failed. Please try again.', 'error');
        }
    }

    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = `
            <i class="fas fa-${type === 'error' ? 'exclamation-triangle' : type === 'success' ? 'check-circle' : 'info-circle'}"></i>
            <span>${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('show');
        }, 100);
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (document.body.contains(toast)) {
                    document.body.removeChild(toast);
                }
            }, 300);
        }, 5000);
    }

    resetUI() {
        document.getElementById('uploadArea').style.display = 'block';
        document.getElementById('progressContainer').style.display = 'none';
        document.getElementById('resultsContainer').style.display = 'none';
        document.getElementById('fileInfo').style.display = 'none';
        document.getElementById('videoFile').value = '';
        
        this.showToast('Ready for new video upload!', 'success');
    }
}
